## HTTP 헤더 캐시와 조건부 요청

• 캐시 **유효 시간이 초과**해도, 서버의 데이터가 갱신되지 않으면
• **304** Not Modified + **헤더 메타 정보만 응답(바디X)**
• 클라이언트는 서버가 보낸 응답 헤더 정보로 **캐시의 메타 정보**를 갱신
• 클라이언트는 **캐시에 저장되어 있는 데이터 재활용**
• 결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 **헤더 정보만 다운로드**
• 매우 실용적인 해결책

304 Not Modified 헤더만 보내면서 `너의 쿠키로 리다이렉션 해라` 의미를 보냅니다.



## Etag

• 캐시용 데이터에 임의의 **고유한 버전 이름**을 달아둠
•     예) ETag: "v1.0", ETag: "a2jiodwjekjl3"
• 데이터가 변경되면 **이 이름을 바꾸어서 변경**함(Hash를 다시 생성)
•     예) ETag: "aaaaa" -> ETag: "bbbbb"

결국 진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기!



## 캐시 제어 헤더

**Cache-Control: 캐시 제어**

• Cache-Control: max-age
• 캐시 유효 시간, 초 단위

• Cache-Control: no-cache
• 데이터는 캐시해도 되지만, 항상 **원(origin) 서버**(=중간에 있는 캐시 서버말고 진짜 서버)에 검증하고 사용

• Cache-Control: no-store
• 데이터에 민감한 정보가 있으므로 저장하면 안됨
(메모리에서 사용하고 최대한 빨리 삭제)

