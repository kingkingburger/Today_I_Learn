## Ioc 란?

`Ioc(Inversion of contorll)` 제어의 역전

주도권이 스프링에게 있습니다. 내가 오브젝트를 직접 new를 해서 `heap` 메모리 공간에 올리는 것은 하나의 메서드에서 밖에 사용이 됩니다. 다른 메서드에서 사용하려면 **매개변수**로 넘기거나, **다시 new**를 해서 `heap`공간에 띄어 놔야하지요 그럼 각각 다른 의자가 메모리에 있습니다.



스프링은 오브젝트를 스킨해서 `heap`메모리 공간에 띄어놓습니다. 즉, 스프링이 내가 만든 오브젝트를 자기가 알아서 메모리에 띄어 놓습니다. 이게 **제어의 역전** 입니다.





## DI란?

`Dependency Injection` 의존성 주입

Ioc로 스프링이 객체를 관리합니다. 내가 만드는 클래스의 메소드에서 스프링이 만든 것을 사용할 수 있습니다. 
그러면 똑같은 객체를 사용합니다.  스프링은 싱글톤으로 `heap`에 오브젝트 1개만 만들어 놓기 때문에 이것을 가져다 쓸 수 있는 것이 **DI** 입니다.





## 스프링은 엄청나게 많은 필터를 가지고 있다.

필터 = 문지기

문지기에 임무를 줘서 ~~는 걸러라! 하고 명령을 내릴 수 있습니다. 스프링 자체에서는 이러한 필터 기능이 있습니다. 필터들 중에 사용되지 않는 필터를 사용하겠다고 할 수 도 있습니다. 내가 필터를 만들 수 있죠

`톰켓`이 밖깥쪽 성이고 왕의 집을 `스프링` 이라고 합시다.

톰켓이 가지고 있는 필터는 실제로 `fillter`라고 불립니다. 필터안에 파일을 web.xml이라고 부릅니다.

스프링 컨테이너가 가지고 있는 필터는 `인터셉터`라고 불립니다. 인터셉터도 필터와 비슷한 일을 합니다. 권한이 있다면 들여보내고 아니면 내칩니다.





## 스프링에 어노테이션에 대해

컴파일 체킹에 대해 설명하기 전에 어노테이션의 이해가 있어야 합니다. 어노테이션은 컴파일러가 뭔가 체킹할 수 있게 힌트를 주는 역할을 합니다.

`@override`라고 붙히면 컴파일 할 때 컴파일러가 부모 클레스에 똑같은 메서드가 있는지 확인을 하고 있다면 오버라이드 하겠지만  없다면 컴파일 체킹오류를 띄웁니다.

스프링에서 어노테이션은 주로 객체 생성을 할 때 씁니다. `@Component` , `@Bean`, `@Controller` 이런 어노테이션을 만들어 놓습니다.

에를 들어`@component`가 붙어 있는 클래스를 메모리에 로딩하게 합니다. **Ioc로 스프링이 객체를 만들 때 사용합니다.**
`@Autowired`가 붙어있다면 로딩된 객체를 해당 변수에 집어 넣어라는 명령이 됩니다. 스프링이 클래스를 스캔 할 때 내부에 어떤에가 있는지 분석합니다. 이것을 **리플렉션**이라고 합니다. 이 때 어노테이션을 확인하고 `@Autowired`를 만나면 스프링이 만든 `heap`에서 같은 **타입**의 데이터가 있는지 확인하고 변수에 연결을 해줍니다. **이것이 DI 입니다.**

리플렉션은 런타임시에 클래스 전체를 분석 합니다.







