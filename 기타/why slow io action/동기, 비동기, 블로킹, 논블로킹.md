
🟦 이것들 뭔대?
동기, 비동기 / 블로킹, 논 블로킹 / async await 들에 대해서 들어는 봤어요. 정확히 알지는 못하지만 잘 사용하고 있었겠죠. 이것들의 원리에 대해서 궁금해요. python으로 프로젝트를 하다 상태를 기반으로 작업을 처리해야 할 것이 있었어요. 거기서 동기, 비동기 계념을 잘 모르고 사용하니 디버깅이 어렵고 동작하는 순서 예상이 안되더라구요. 계념을 다시 잡고 어떤 원리로 처리하는지, 어떻게 사용하는지 알아봐요.


🟦 이게 왜 탄생했냐?
특정 기능이 있다면 만든 의도가 있을꺼에요. "느린 i/o(입력/출력)을 처리하는 동안 빠른 cpu를 어떻게 낭비하지 않을 것인가?". 이 문제를 해결하기 위해 나온 개념들이 동기/비동기, 블로킹/논블로킹이에요.

🟦 왜 i/o 작업은 느린가?
cpu는 너무 빠른데, 외부 장치들은 물리적인 한계 때문에 그 속도를 따라갈 수 없어서에요.


🟦 현실로 비유해서 왜 비동기가 필요한지 느껴봅니다.
저는 엄청난 천재(CPU)라서 1초 만에 복잡한 수학 문제를 풀 수 있습니다.
- **동기/블로킹 (Sync/Blocking):** 
    - 미국 지사(서버)에 서류를 요청했습니다.
    - 그 서류가 올 때까지 **15년 동안(네트워크 대기)** 아무것도 안 하고 책상에 멍하니 앉아 있습니다.
    - **결과:** 인생(CPU 자원) 낭비입니다.
- **비동기/논블로킹 (Async/Non-blocking):**
    - 미국 지사에 서류를 요청해두고(요청 전송), "도착하면 알려줘(Callback/Await)"라고 말합니다.
    - 그동안 밀린 다른 업무를 처리하거나 게임을 하거나 공부를 합니다.
    - **결과:** 15년의 시간을 알차게 썼습니다.

이 "물리적인 속도 차이"가 극심하기 때문에, **CPU를 놀게 하지 않으려는 노력**에서 논블로킹 I/O와 비동기 프로그래밍이 탄생했습니다.


🟦 그러면 os는 이 느린 i/o를 기다리지 않고 어떻게 처리하는가?
계념을 명확하게 구분하기 위해 가장 먼저 이해해야 할 두 가지 축이 있습니다.
- 제어권(Blocking vs Non-Blocking)
	- Blocking: "내 작업 끝날 때까지 기다려". (제어권을 안 돌려줌)
	- Non-Blocking: "일단 알겠고, 너 할 거 하러가" (제어권을 바로 돌려줌)

- 결과의 처리 (Synchronous vs Asynchronous)
	- Synchronous(동기): 호출한 놈이 결과가 나왔는지 계속 확인하거나 기다림.
	- Asynchronous(비동기): 호출한 놈은 신경 끄고 있음. 작업 끝난 놈이 알아서 알려줌(Callback)

🟦 4가지 상황 조합을 할 수 있어요.
- blocking - synchronous
- blocking - asynchronous
- Non-blocking - synchronous
- Non-blocking - asynchronous

🟦 우리는 네트워크에서 데이터를 다운로드 하는 함수 download()를 호출한다고 가정합니다. 이 download()는 3초가 걸립니다.
### 1. 동기 + 블로킹 (Synchronous Blocking)

**"전통적인 방식: 끝날 때까지 꼼짝 마!"**

가장 일반적인 형태입니다. 함수를 호출하면 리턴값이 올 때까지 프로그램(메인 스레드)이 **멈춥니다.**
```
import time

def sync_blocking():
    print("1. 다운로드 요청 (제어권 넘겨줌, 결과 기다림)")
    
    # [Blocking] 3초 동안 여기서 코드 실행이 멈춥니다.
    # 이 줄이 끝나야 다음 줄로 넘어갑니다.
    data = network.download_file() 
    
    print(f"2. 데이터 수신 완료: {data}")
    print("3. 다음 작업 진행")

# 실행
sync_blocking()
```
- **핵심:** `network.download_file()`이 끝날 때까지 아무것도 못 합니다.
    
- **OS 관점:** 커널이 데이터가 도착할 때까지 프로세스를 `Sleep` 상태로 만듭니다.

### 2. 동기 + 논블로킹 (Synchronous Non-blocking)

**"폴링(Polling): 아직이야? 아직이야? (CPU 낭비)"**

함수를 호출하면 **즉시 리턴**됩니다(Non-blocking). 하지만 데이터가 아직 없으므로 빈 값이나 에러를 줍니다. 우리는 데이터가 필요하므로, **반복문(while)**을 돌면서 계속 물어봅니다(Synchronous).
```
import time

def sync_non_blocking():
    print("1. 다운로드 요청")
    
    # 소켓을 '논블로킹 모드'로 설정
    network.socket.setblocking(False)
    
    # [Polling] 반복해서 확인
    data = None
    while not data:
        try:
            # [Non-blocking] 데이터 없으면 즉시 에러(EWOULDBLOCK) 발생 후 리턴
            data = network.socket.recv()
        except BlockingIOError:
            print("   ...데이터 아직 안 옴 (딴짓 가능하지만, 확인하느라 바쁨)")
            # 여기서 잠깐 딴짓을 할 수 있지만, 다시 금방 확인하러 와야 함
            time.sleep(0.1) 
            
    print(f"2. 데이터 수신 완료: {data}")
    print("3. 다음 작업 진행")

# 실행
sync_non_blocking()
```
- **핵심:** 멈추지는 않지만(Non-blocking), 결과를 받기 위해 계속 확인(Sync)해야 하므로 CPU를 계속 사용합니다.
    
- **OS 관점:** 프로세스가 쉬지 않고 시스템 콜(`recv`)을 호출하여 CPU 점유율이 치솟습니다.


### 3. 비동기 + 블로킹 (Asynchronous Blocking)

**"비효율의 끝판왕: 시켜놓고 멍하니 기다리기"**

작업을 별도 스레드나 백그라운드(비동기)로 던졌습니다. 그런데 그 결과를 받기 위해 메인 스레드가 **멈춰서 기다립니다(Blocking).**
```
import concurrent.futures

def async_blocking():
    print("1. 비동기 작업 시작 (별도 스레드에 위임)")
    
    # [Asynchronous] 별도 일꾼(Thread)에게 작업을 시킴
    future = thread_pool.submit(network.download_file)
    
    print("   (여기서 다른 일을 할 수 있었는데...)")
    
    # [Blocking] 시켜놓고 결과가 나올 때까지 멈춰서 기다림
    # 비동기의 장점을 스스로 없애버림
    result = future.result() 
    
    print(f"2. 데이터 수신 완료: {result}")
    print("3. 다음 작업 진행")

# 실행
async_blocking()
```
- **핵심:** `submit`으로 비동기 요청을 했지만, `result()`를 호출하는 순간 블로킹됩니다.
    
- **이런 코드가 나오는 이유:** 보통 개발자가 비동기 라이브러리를 쓰면서 흐름을 동기식으로 제어하고 싶을 때(실수 혹은 의도적 동기화) 발생합니다.

### 4. 비동기 + 논블로킹 (Asynchronous Non-blocking)

**"이상적인 모델: 시켜놓고 내 할 일 하기"**

작업을 요청하고 **즉시 리턴**받습니다(Non-blocking). 결과는 나중에 **콜백(Callback)** 함수나 이벤트가 발생하면 처리합니다(Asynchronous). 기다리지 않습니다.

```
def on_complete(data):
    # 나중에(3초 뒤) 호출되는 함수
    print(f"3. [알림] 데이터 수신 완료: {data}")

def async_non_blocking():
    print("1. 다운로드 요청 (콜백 함수 등록)")
    
    # [Non-blocking + Async] 
    # "다운로드해줘. 끝나면 on_complete 함수 실행해줘." 라고 말하고 즉시 리턴
    network.download_file(callback=on_complete)
    
    print("2. 나는 기다리지 않고 내 할 일을 계속한다 (UI 업데이트, 계산 등)")
    # 메인 스레드는 여기서 계속 다른 작업을 수행함

# 실행
async_non_blocking()
```
- **실행 순서:** 1 -> 2 -> (3초 뒤) -> 3
    
- **핵심:** 가장 효율적입니다. I/O 작업은 OS가 처리하고, 메인 스레드는 그동안 다른 연산을 처리할 수 있습니다.
    
- **OS 관점:** `epoll` (Linux), `kqueue` (Mac), `IOCP` (Windows) 같은 고성능 이벤트 통지 기능을 사용합니다.

배달로 비유해보기
|**모델**|**코드 형태**|**특징**|**비유**|
|---|---|---|---|
|**동기 블로킹**|`data = read()`|멈춤. 가장 쉬움.|배달 올 때까지 현관 앞에서 대기.|
|**동기 논블로킹**|`while: read()`|바쁨. CPU 낭비 심함.|배달 왔냐고 1초마다 인터폰 확인.|
|**비동기 블로킹**|`task.wait()`|비동기인데 기다림. 모순.|배달 시키고(비동기), 올 때까지 현관 앞 대기.|
|**비동기 논블로킹**|`read(callback)`|안 멈춤. 효율 최고.|배달 시키고 게임하다가, 벨 울리면(Callback) 받음.|


깊이가 얕은듯 😅 